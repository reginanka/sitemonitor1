import os
import json
import hashlib
import requests
from datetime import datetime, timedelta
from pathlib import Path
import logging
from typing import Dict, List, Tuple, Optional

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Å—Ç–∞–Ω–∏ –∑ environment
API_BASE_URL = os.getenv('API_BASE_URL')
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
TELEGRAM_CHANNEL_ID = os.getenv('TELEGRAM_CHANNEL_ID')
TELEGRAM_LOG_CHANNEL_ID = os.getenv('TELEGRAM_LOG_CHANNEL_ID')

# –ß–µ—Ä–≥–∏: cherga_id 1-6, pidcherga_id 1-2 (–≤—Å—å–æ–≥–æ 12)
QUEUES = [(i, j) for i in range(1, 7) for j in range(1, 3)]

# –î–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó
DATA_DIR = Path('data')
IMAGES_DIR = Path('images')
DATA_DIR.mkdir(exist_ok=True)
IMAGES_DIR.mkdir(exist_ok=True)

# –§–∞–π–ª–∏
CURRENT_FILE = DATA_DIR / 'current.json'
PREVIOUS_FILE = DATA_DIR / 'previous.json'
HISTORY_FILE = DATA_DIR / 'history.json'
HASH_FILE = DATA_DIR / 'last_hash.json'


# ============================================================================
# –§–£–ù–ö–¶–Ü–á –î–õ–Ø –†–û–ë–û–¢–ò –ó API
# ============================================================================

def fetch_schedule(cherga_id: int, pidcherga_id: int) -> List[Dict]:
    """–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –≥—Ä–∞—Ñ—ñ–∫ –¥–ª—è –æ–¥–Ω—ñ—î—ó —á–µ—Ä–≥–∏ –∑ API"""
    try:
        params = {'cherga_id': cherga_id, 'pidcherga_id': pidcherga_id}
        response = requests.get(API_BASE_URL, params=params, timeout=10)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        logger.error(f"–ü–æ–º–∏–ª–∫–∞ –∑–∞–ø–∏—Ç—É {cherga_id}.{pidcherga_id}: {e}")
        return []


def fetch_all_schedules() -> Dict[str, List[Dict]]:
    """–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –≥—Ä–∞—Ñ—ñ–∫–∏ –¥–ª—è –≤—Å—ñ—Ö 12 —á–µ—Ä–≥"""
    all_schedules = {}
    logger.info("üì° –ó–∞–≤–∞–Ω—Ç–∞–∂—É—é –≥—Ä–∞—Ñ—ñ–∫–∏ –¥–ª—è –≤—Å—ñ—Ö —á–µ—Ä–≥...")
    
    for cherga_id, pidcherga_id in QUEUES:
        queue_key = f"{cherga_id}.{pidcherga_id}"
        schedule = fetch_schedule(cherga_id, pidcherga_id)
        all_schedules[queue_key] = schedule
        logger.info(f"  ‚úì {queue_key}: {len(schedule)} –∑–∞–ø–∏—Å—ñ–≤")
    
    return all_schedules


# ============================================================================
# –§–£–ù–ö–¶–Ü–á –î–õ–Ø –û–ë–†–û–ë–ö–ò –ß–ê–°–Ü–í
# ============================================================================

def parse_time_intervals(schedule: List[Dict]) -> Dict[str, List[Tuple[str, str]]]:
    """
    –ü–∞—Ä—Å–∏—Ç–∏ 30-—Ö–≤–∏–ª–∏–Ω–Ω—ñ —ñ–Ω—Ç–µ—Ä–≤–∞–ª–∏ –≤ –¥—ñ–∞–ø–∞–∑–æ–Ω–∏ —á–∞—Å—É
    –ü–æ–≤–µ—Ä—Ç–∞—î: {'11.12.2025': [('00:00', '03:00'), ('06:00', '09:00'), ...]}
    """
    intervals_by_date = {}
    
    for entry in schedule:
        date = entry.get('date')
        span = entry.get('span')
        color = entry.get('color')
        
        if not all([date, span, color]):
            continue
        
        if date not in intervals_by_date:
            intervals_by_date[date] = {'red': [], 'white': []}
        
        start_time, end_time = span.split('-')
        intervals_by_date[date][color].append((start_time, end_time))
    
    # –û–±'—î–¥–Ω–∞—Ç–∏ —Å—É–º—ñ–∂–Ω—ñ —ñ–Ω—Ç–µ—Ä–≤–∞–ª–∏
    merged_intervals = {}
    for date, colors in intervals_by_date.items():
        merged_intervals[date] = merge_intervals(colors['red'])
    
    return merged_intervals


def merge_intervals(intervals: List[Tuple[str, str]]) -> List[Tuple[str, str]]:
    """–û–±'—î–¥–Ω–∞—Ç–∏ —Å—É–º—ñ–∂–Ω—ñ —á–∞—Å–æ–≤—ñ —ñ–Ω—Ç–µ—Ä–≤–∞–ª–∏"""
    if not intervals:
        return []
    
    # –°–æ—Ä—Ç—É–≤–∞—Ç–∏
    intervals = sorted(intervals, key=lambda x: x[0])
    merged = [intervals[0]]
    
    for start, end in intervals[1:]:
        last_start, last_end = merged[-1]
        # –Ø–∫—â–æ –Ω–æ–≤—ñ —ñ–Ω—Ç–µ—Ä–≤–∞–ª–∏ —Å—É–º—ñ–∂–Ω—ñ
        if start == last_end:
            merged[-1] = (last_start, end)
        else:
            merged.append((start, end))
    
    return merged


def calculate_duration(start: str, end: str) -> float:
    """–†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å –≤ –≥–æ–¥–∏–Ω–∞—Ö"""
    start_h, start_m = map(int, start.split(':'))
    end_h, end_m = map(int, end.split(':'))
    
    start_mins = start_h * 60 + start_m
    end_mins = end_h * 60 + end_m
    
    # –ß–∞—Å –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ –æ–ø—ñ–≤–Ω—ñ—á—å
    if end_mins < start_mins:
        end_mins += 24 * 60
    
    duration_mins = end_mins - start_mins
    return duration_mins / 60


def get_day_name(date_str: str) -> str:
    """–û—Ç—Ä–∏–º–∞—Ç–∏ –Ω–∞–∑–≤—É –¥–Ω—è —Ç–∏–∂–Ω—è –¥–ª—è –¥–∞—Ç–∏ —Ñ–æ—Ä–º–∞—Ç—É DD.MM.YYYY"""
    try:
        day, month, year = map(int, date_str.split('.'))
        date = datetime(year, month, day)
        days = ['–ø–Ω', '–≤—Ç', '—Å—Ä', '—á—Ç', '–ø—Ç', '—Å–±', '–Ω–¥']
        return days[date.weekday()]
    except:
        return "–Ω–µ–≤—ñ–¥–æ–º–æ"


# ============================================================================
# –§–£–ù–ö–¶–Ü–á –î–õ–Ø –ü–û–†–Ü–í–ù–Ø–ù–ù–Ø –ì–†–ê–§–Ü–ö–Ü–í
# ============================================================================

def compare_schedules(current: Dict[str, List[Dict]], 
                     previous: Dict[str, List[Dict]]) -> Dict:
    """
    –ü–æ—Ä—ñ–≤–Ω—è—Ç–∏ –ø–æ—Ç–æ—á–Ω—ñ —Ç–∞ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ –≥—Ä–∞—Ñ—ñ–∫–∏
    –ü–æ–≤–µ—Ä—Ç–∞—î: {'1.1': {'10.12.2025': {'added': [...], 'removed': [...]}}}
    """
    changes = {}
    
    for queue_key, current_schedule in current.items():
        current_intervals = parse_time_intervals(current_schedule)
        previous_schedule = previous.get(queue_key, [])
        previous_intervals = parse_time_intervals(previous_schedule)
        
        queue_changes = {}
        
        # –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —É—Å—ñ –¥–∞—Ç–∏
        all_dates = set(current_intervals.keys()) | set(previous_intervals.keys())
        
        for date in all_dates:
            current_times = set(current_intervals.get(date, []))
            previous_times = set(previous_intervals.get(date, []))
            
            added = list(current_times - previous_times)
            removed = list(previous_times - current_times)
            
            if added or removed:
                queue_changes[date] = {
                    'added': sorted(added),
                    'removed': sorted(removed)
                }
        
        if queue_changes:
            changes[queue_key] = queue_changes
    
    return changes


# ============================================================================
# –§–£–ù–ö–¶–Ü–á –î–õ–Ø –§–û–†–ú–ê–¢–£–í–ê–ù–ù–Ø
# ============================================================================

def format_message(changes: Dict, timestamp: str) -> Optional[str]:
    """
    –§–æ—Ä–º–∞—Ç—É–≤–∞—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—ñ–¥ –ø–æ—Ç—Ä—ñ–±–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç
    """
    if not changes:
        return None
    
    changed_queues = ', '.join(sorted(changes.keys()))
    message = f"–î–ª—è –≥—Ä—É–ø {changed_queues} - –æ–Ω–æ–≤–ª–µ–Ω–æ –≥—Ä–∞—Ñ—ñ–∫ –≤–∏–º–∫–Ω–µ–Ω–Ω—è —Å–≤—ñ—Ç–ª–∞.\n\n"
    
    # –í—ñ–¥—Å–æ—Ä—Ç—É–≤–∞—Ç–∏ —á–µ—Ä–≥–∏ —Ç–∞ –¥–∞—Ç–∏
    for queue_key in sorted(changes.keys()):
        queue_changes = changes[queue_key]
        message += f"–∑–∞ –≥—Ä—É–ø–æ—é {queue_key}:\n"
        
        for date in sorted(queue_changes.keys()):
            day_changes = queue_changes[date]
            
            # –ü–∞—Ä—Å–∏—Ç–∏ –¥–∞—Ç—É
            day_name = get_day_name(date)
            message += f"  {day_name}, {date}:\n"
            
            # –í–∏–¥–∞–ª–µ–Ω—ñ —ñ–Ω—Ç–µ—Ä–≤–∞–ª–∏ (–∑—ñ –∑–∞—á–µ—Ä–∫—É–≤–∞–Ω–Ω—è–º)
            for start, end in sorted(day_changes['removed']):
                duration = calculate_duration(start, end)
                message += f"  ‚ùå {start} - {end} ‚Äì –Ω–∞ {duration:.0f} –≥–æ–¥\n"
            
            # –î–æ–¥–∞–Ω—ñ —ñ–Ω—Ç–µ—Ä–≤–∞–ª–∏
            for start, end in sorted(day_changes['added']):
                duration = calculate_duration(start, end)
                message += f"  üî¥ {start} - {end} ‚Äì –Ω–∞ {duration:.0f} –≥–æ–¥\n"
            
            message += "\n"
    
    # –î–æ–¥–∞—Ç–∏ timestamp
    message += f"–î–∞—Ç–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó - {timestamp}"
    
    return message


# ============================================================================
# –§–£–ù–ö–¶–Ü–á –î–õ–Ø –†–û–ë–û–¢–ò –ó –§–ê–ô–õ–ê–ú–ò
# ============================================================================

def save_json(data: Dict, filepath: Path):
    """–ó–±–µ—Ä–µ–≥—Ç–∏ –¥–∞–Ω—ñ –≤ JSON"""
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


def load_json(filepath: Path) -> Dict:
    """–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –¥–∞–Ω—ñ –∑ JSON"""
    if not filepath.exists():
        return {}
    with open(filepath, 'r', encoding='utf-8') as f:
        return json.load(f)


def calculate_hash(data: Dict) -> str:
    """–†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ MD5 —Ö–µ—à –¥–∞–Ω–∏—Ö"""
    json_str = json.dumps(data, sort_keys=True, ensure_ascii=False)
    return hashlib.md5(json_str.encode()).hexdigest()


def load_last_hash() -> Dict:
    """–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –æ—Å—Ç–∞–Ω–Ω—ñ–π —Ö–µ—à"""
    return load_json(HASH_FILE)


def save_last_hash(schedules: Dict, timestamp: str):
    """–ó–±–µ—Ä–µ–≥—Ç–∏ —Ö–µ—à –ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å—Ç–∞–Ω—É"""
    hash_data = {
        'timestamp': timestamp,
        'schedules_hash': calculate_hash(schedules),
        'last_notification': timestamp,
        'queues': {
            queue_key: calculate_hash(schedule) 
            for queue_key, schedule in schedules.items()
        }
    }
    save_json(hash_data, HASH_FILE)


def save_to_history(changes: Dict, timestamp: str):
    """–ó–±–µ—Ä–µ–≥—Ç–∏ –∑–º—ñ–Ω–∏ –≤ —ñ—Å—Ç–æ—Ä—ñ—é"""
    history = load_json(HISTORY_FILE)
    if not isinstance(history, list):
        history = []
    
    history.append({
        'timestamp': timestamp,
        'changes': changes
    })
    
    # –ó–±–µ—Ä–µ–≥—Ç–∏ —Ç—ñ–ª—å–∫–∏ –æ—Å—Ç–∞–Ω–Ω—ñ 100 –∑–∞–ø–∏—Å—ñ–≤
    if len(history) > 100:
        history = history[-100:]
    
    save_json(history, HISTORY_FILE)


# ============================================================================
# –û–°–ù–û–í–ù–ê –§–£–ù–ö–¶–Ü–Ø
# ============================================================================

def main():
    """–û—Å–Ω–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É"""
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    logger.info(f"\n{'='*60}")
    logger.info(f"üöÄ –°–¢–ê–†–¢ –ú–û–ù–Ü–¢–û–†–ò–ù–ì–£ [{timestamp}]")
    logger.info(f"{'='*60}\n")
    
    try:
        # 1. –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ø–æ—Ç–æ—á–Ω—ñ –≥—Ä–∞—Ñ—ñ–∫–∏
        logger.info("–ö—Ä–æ–∫ 1: –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≥—Ä–∞—Ñ—ñ–∫—ñ–≤...")
        current_schedules = fetch_all_schedules()
        
        if not current_schedules:
            logger.error("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—å –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –≥—Ä–∞—Ñ—ñ–∫–∏!")
            return
        
        # 2. –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ö–µ—à - —á–∏ –¥—ñ–π—Å–Ω–æ –∑–º—ñ–Ω–∏–ª–æ—Å—å —â–æ—Å—å
        logger.info("\n–ö—Ä–æ–∫ 2: –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ö–µ—à—É...")
        last_hash_data = load_last_hash()
        current_hash = calculate_hash(current_schedules)
        
        if current_hash == last_hash_data.get('schedules_hash'):
            logger.info("‚úÖ –î–∞–Ω—ñ –Ω–µ –∑–º—ñ–Ω–∏–ª–∏—Å—è. –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è.")
            logger.info("='*60\n")
            return
        
        logger.info("‚ö†Ô∏è  –î–∞–Ω—ñ –∑–º—ñ–Ω–∏–ª–∏—Å—è! –ü—Ä–æ–≤–æ–¥–∂—É –∞–Ω–∞–ª—ñ–∑...")
        
        # 3. –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ –≥—Ä–∞—Ñ—ñ–∫–∏
        logger.info("\n–ö—Ä–æ–∫ 3: –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ—Ö –≥—Ä–∞—Ñ—ñ–∫—ñ–≤...")
        previous_schedules = load_json(PREVIOUS_FILE)
        
        # 4. –ü–æ—Ä—ñ–≤–Ω—è—Ç–∏
        logger.info("\n–ö—Ä–æ–∫ 4: –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –≥—Ä–∞—Ñ—ñ–∫—ñ–≤...")
        changes = compare_schedules(current_schedules, previous_schedules)
        
        if changes:
            logger.info(f"‚úì –ó–Ω–∞–π–¥–µ–Ω–æ –∑–º—ñ–Ω–∏ –≤ {len(changes)} —á–µ—Ä–≥–∞—Ö:")
            for queue_key in sorted(changes.keys()):
                logger.info(f"  - {queue_key}")
            
            # 5. –§–æ—Ä–º–∞—Ç—É–≤–∞—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
            logger.info("\n–ö—Ä–æ–∫ 5: –§–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è...")
            message = format_message(changes, timestamp)
            
            if message:
                logger.info(f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≥–æ—Ç–æ–≤–æ:\n{message}\n")
                
                # 6. –ó–±–µ—Ä–µ–≥—Ç–∏ –≤ —ñ—Å—Ç–æ—Ä—ñ—é
                logger.info("–ö—Ä–æ–∫ 6: –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤ —ñ—Å—Ç–æ—Ä—ñ—é...")
                save_to_history(changes, timestamp)
                
                # 7. –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∫–∞—Ä—Ç–∏–Ω–∫–∏
                logger.info("\n–ö—Ä–æ–∫ 7: –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∫–∞—Ä—Ç–∏–Ω–∫–∏...")
                try:
                    from image_generator import generate_image
                    image_path = generate_image(changes, timestamp)
                    logger.info(f"‚úì –ö–∞—Ä—Ç–∏–Ω–∫–∞ —Å—Ç–≤–æ—Ä–µ–Ω–∞: {image_path}")
                except Exception as e:
